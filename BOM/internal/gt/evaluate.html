<html>
	<head>
	<script src="../../js/rectlib.js"></script>
	<script src="polyk.js"></script>
	<script>
		
var e = undefined;
var tt = 20;

function GTObj() {
	this.nodes = [];
	this.eout = 0;
	this.ein = 0;
	this.weight = 0;
}


function centroid(p1,p2,p3)  {
	return({x:(p1.x+p2.x+p3.x)/3,y:(p1.y+p2.y+p3.y)/3})
}

function Block() {
	this.id = "";
	this.ecover = 0;
	this.tcover = 0;
	
	this.originalRect = {x:0,y:0,w:0,h:0}
	this.computedRect = {x:0,y:0,w:0,h:0}
	
	this.weight = function() {
		return(this.ecover*this.tcover);
	}
	
	//~ this.fixProportions = function(nw,nh,ow,oh) {
		//~ this.computedRect.x = nw*this.originalRect.x / ow;
		//~ this.computedRect.y = nh*this.originalRect.y / oh;
		//~ this.computedRect.w = nw*this.originalRect.w / ow;
		//~ this.computedRect.h = nh*this.originalRect.h / oh;
		//~ this.computedRect.right = 0 +this.computedRect.w
		//~ this.computedRect.bottom = 0 + this.computedRect.h
	//~ }
	this.fixProportions = function(nw,nh,ow,oh) {
		this.computedRect = this.originalRect;
	}
	
	this.contains = function(block,tt) {
		var my = this.computedRect;
		var his = block.computedRect;
		var left,right,left_p,right_p;
		var hp,vp;
		var ret = false;
		if (!tt) tt=0;
		
		// resolving horizontal projection
		hp = ((my.x-tt) < his.x) && (his.w < (my.w+tt)) && (his.x < his.w)
		vp = ((my.y-tt) < his.y) && (his.h < (my.h+tt)) && (his.y < his.h)
		
		ret = hp && vp
		return(ret)
	}
	
	
	
	this.equals = function(block,tt) {
		var equal = false;
		if (!tt) tt=0;
		var dxy,dxh,dwh,dwy;
		dxy = PolyK._P.dist(new PolyK._P(this.computedRect.x,this.computedRect.y),new PolyK._P(block.computedRect.x,block.computedRect.y));
		dxh = PolyK._P.dist(new PolyK._P(this.computedRect.x,this.computedRect.h),new PolyK._P(block.computedRect.x,block.computedRect.h));
		dwh = PolyK._P.dist(new PolyK._P(this.computedRect.w,this.computedRect.h),new PolyK._P(block.computedRect.w,block.computedRect.h));
		dwy = PolyK._P.dist(new PolyK._P(this.computedRect.w,this.computedRect.y),new PolyK._P(block.computedRect.w,block.computedRect.y));
		
		equal = (dxy<=tt) && (dxh<=tt) &&  (dwh<=tt) && (dwy<=tt);
		return(equal);
	}
	
	this.getPolygonPoints = function(tolerance) {
		var res = [];
		var t = tolerance || 0;
		var dim = this.computedRect;
		res = res.concat([dim.x-t,dim.y-t]);
		res = res.concat([dim.x-t,dim.y+dim.h+t]);
		res = res.concat([dim.x+dim.w+t,dim.y+dim.h+t]);
		res = res.concat([dim.x+dim.w+t,dim.y-t]);
		return(res);
	}
}
	
function Segmentation() {
	this.url = "";
	this.originalWidth = 0;
	this.originalHeight = 0;
	this.computedWidth = 0;
	this.computedHeight = 0;
	this.browser = "";
	this.algorithm = "";
	this.category = "";
	this.blocks = [];
	
	// ESTO ESTA DESABILITADO PORQUE LA DATA YA VIENE NORMALIZADA
	//~ this.fixProportions = function(nw,nh) {
		//~ if (this.originalWidth < this.originalHeight) {
			//~ this.computedHeight = nh; //solve(undefined, nh, this.originalWidth, this.originalHeight);
			//~ this.computedWidth = solve(undefined, nh, this.originalWidth, this.originalHeight);
		//~ } else {
			//~ this.computedWidth = nw; //solve(undefined, nh, this.originalWidth, this.originalHeight);
			//~ this.computedHeight = solve(nw, undefined, this.originalWidth, this.originalHeight);
		//~ }
		//~ for (var i=0;i<this.blocks.length;i++) {
			//~ this.blocks[i].fixProportions(this.computedWidth,this.computedHeight,this.originalWidth,this.originalHeight);
		//~ }
	//~ } 
	this.fixProportions = function(nw,nh) {
		this.computedWidth = this.originalWidth;
		this.computedHeight = this.originalHeight;
		for (var i=0;i<this.blocks.length;i++) {
			this.blocks[i].fixProportions(this.computedWidth,this.computedHeight,this.originalWidth,this.originalHeight);
		}
	}
}
	
function Evaluation() {
	var gt = undefined;
	var seg = undefined;
	var page = "";
	var rows;
	var graphG;
	var graphS;
	var tt=0;
	
	this.loadSegmentation = function(xseg,win,algorithm,browser) {
		var block={};
		doc = win.document;
		rows = doc.getElementsByTagName("tr");
		
		if (xseg == "gt") {
			this.gt = new Segmentation();
			this.gt.url = this.page;
			this.gt.browser = browser;
			this.gt.algorithm = algorithm;
		} else {
			this.seg = new Segmentation();
			this.seg.url = this.page;
			this.seg.browser = browser;
			this.seg.algorithm = algorithm;
		}
		
		
		for(var i=1;i<rows.length;i++) {
		
			if (xseg=="gt") {
				if (!this.gt.originalWidth) 	this.gt.originalWidth 	= parseInt(rows[i].children[1].innerText);
				if (!this.gt.originalHeight)	this.gt.originalHeight	= parseInt(rows[i].children[2].innerText);
			} else {
				if (!this.seg.originalWidth) 	this.seg.originalWidth 	= parseInt(rows[i].children[1].innerText);
				if (!this.seg.originalHeight)	this.seg.originalHeight	= parseInt(rows[i].children[2].innerText);
			}
		
			block = new Block();
			block.id = rows[i].children[0].innerText;
			block.originalRect.x = parseInt(rows[i].children[3].innerText);
			block.originalRect.y = parseInt(rows[i].children[4].innerText);
			block.originalRect.w = parseInt(rows[i].children[5].innerText);
			block.originalRect.h = parseInt(rows[i].children[6].innerText);
			block.ecover = parseInt(rows[i].children[7].innerText);
			block.tcover = parseInt(rows[i].children[8].innerText);
			
			if (xseg=="gt") {
				if (block.originalRect.w > this.gt.originalWidth)
					alert("GT:"+algorithm+" Document and blocks geometry do not match bw:"+block.originalRect.w +",dw:"+ this.gt.originalWidth);
					//this.gt.originalWidth = block.originalRect.w;
				if (block.originalRect.h > this.gt.originalHeight)
					alert("GT:"+algorithm+" Document and blocks geometry do not match bh:"+block.originalRect.h +",dh:"+ this.gt.originalHeight);
					//this.gt.originalHeight = block.originalRect.h;
				this.gt.blocks.push(block);
			} else {
				if (block.originalRect.w > this.seg.originalWidth)
					alert("SEG:"+algorithm+" Document and blocks geometry do not match bw:"+block.originalRect.w +",dw:"+ this.seg.originalWidth);
					//this.seg.originalWidth = block.originalRect.w;
				if (block.originalRect.h > this.seg.originalHeight)
					alert("SEG:"+algorithm+" Document and blocks geometry do not match bh:"+block.originalRect.h +",dh:"+ this.seg.originalHeight);
					//this.seg.originalHeight = block.originalRect.h;
				this.seg.blocks.push(block);
			}
		}
	}
	
	this.loaded = function() {
		return( ('undefined' !== typeof this.gt) && ('undefined' !== typeof this.seg) );
	}
	
	this.fixProportions = function() {
		var nw = 100;
		var nh = 100;
		this.gt.fixProportions(nw,nh);
		this.seg.fixProportions(nw,nh);
	}
	
	this.evaluate2 = function(tr,tt) {
		var gb,sb;
		this.graphG = {};
		this.graphS = {};
		for (var g=0;g<this.gt.blocks.length;g++) {
			gb = this.gt.blocks[g];
			for (var s=0;s<this.seg.blocks.length;s++) {
				sb = this.seg.blocks[s];
				drawCurrentRects(gb,sb,tt);
				if (sb.equals(gb,tt)) {
					addUniqueTo(this.graphG,this.graphS,gb,sb)
					break;
				} else {
					if (gb.contains(sb,tt)) {
						addUniqueTo(this.graphG,this.graphS,gb,sb)
					}
					if (sb.contains(gb,tt)) {
						addUniqueTo(this.graphS,this.graphG,sb,gb)
					}
				}
			}
		}
	}
	
	
	/****************/
	
	
	this.normarea = function(b) {
		var cont = 0;
		for (var i=0;i<100;i+=10) {
			if (b.computedRect.w>i) cont++; else  break;
		}
		var dw = cont;
		cont = 0;
		for (var i=0;i<100;i+=10) {
			if (b.computedRect.h>i) cont++; else  break;
		}
		var dh = cont;
		
		var d = (dw*dh)/100;
		return(d);
	}
	this.relativeArea = function(b) {
		return(this.normarea(b));
	}
	
	
	/****************/
	
	
	this.weight = function(gb,sb,tt) {
		var ret = 0;
		if (gb.equals(sb,tt)) {
			return gb.weight();
		} else {
			if (gb.contains(sb,tt)) {
				return sb.weight();
			} else {
				if (sb.contains(gb,tt)) {
					return(gb.weight());
				} else {
					return(0);
				}
			}
		}
	}
	this.proportion = function(b1,b2,tt) {
		//~ if (b2.weight()<b1.weight()) {
			return (this.weight(b1,b2,tt) / b1.weight() )
		//~ } else {
			//~ return (this.weight(b2,b1,tt) / b2.weight() )
		//~ }
	}
	this.mixed = function(b1,b2,tt) {
		var p = this.proportion(b1,b2,tt);
		//~ var r1 = this.relativeArea(b1);
		//~ var r2 = this.relativeArea(b2)
		//~ var r = 0;
		//~ if (p!=0) {
			//~ r = (p+r1+r2) / 3
		//~ }
		r=p;
		return r;
	}
	this.significant = function(b1,b2,tr,tt) {
		//~ if (tr==1) return(false);
		if (b1.weight()!=0)
			return (this.mixed(b1,b2,tt) > tr);
		else
			return (false);
	}
	
	this.evaluate = function(tr,tt) {
		var gb,sb;
		this.graphG = {};
		this.graphS = {};
		for (var g=0;g<this.gt.blocks.length;g++) {
			gb = this.gt.blocks[g];
			for (var s=0;s<this.seg.blocks.length;s++) {
				sb = this.seg.blocks[s];
				drawCurrentRects(gb,sb,tt);
				if (this.significant(gb,sb,tr,tt)) {
					console.log("NEW EDGE G ",this.weight(gb,sb,tt)/gb.weight(),"GW",gb.weight(),"SW",sb.weight())
					addUniqueTo(this.graphG,this.graphS,gb,sb)
				}
				if (this.significant(sb,gb,tr,tt)) {
					console.log("NEW EDGE S ",this.weight(sb,gb,tt)/sb.weight(),"SW",sb.weight(),"GW",gb.weight())
					addUniqueTo(this.graphS,this.graphG,sb,gb)
				}
			}
		}
	}
	
	this.generateMatrix = function() {
		console.log(this.graphG);
		for (var i=0;i< this.graphG.length;i++) {
			console.log(this.graphG[i])
		}
	}
}

function addUniqueTo(gfrom,gto,from,to) {
	if (!gfrom[from.id]) gfrom[from.id] = new GTObj();
	if (!gto[to.id]) gto[to.id] = new GTObj();
	
	var flag=false;
	
	for (var k=0;k<gfrom[from.id].nodes.length;k++) {
		if (gfrom[from.id].nodes[k] == to) {
			flag = true;
			break;
		}
	}
	if (!flag)  {
		gfrom[from.id].eout++;
		gto[to.id].ein++;
		gfrom[from.id].nodes.push(to);
	}
	
	flag=false;
	
	for (var k=0;k<gto[to.id].nodes.length;k++) {
		if (gto[to.id].nodes[k] == from) {
			flag = true;
			break;
		}
	}
	
	if (!flag)  {
		gto[to.id].eout++;
		gfrom[from.id].ein++;
		gto[to.id].nodes.push(from);
	}
}


function prepareEvaluation(page,a1,a2,b1,b2) {
	e = new Evaluation();
	e.gt=undefined
	e.seg=undefined
	e.page = page;
	e.loadSegmentation("gt",parent.frames[1],a1,b1);
	e.loadSegmentation("seg",parent.frames[3],a2,b2);
	e.fixProportions();
	if (e.gt && e.seg) console.log(e.gt,e.seg)
	if (e.loaded()) {
		//e.fixProportions();
		document.getElementById("evaloutput").innerHTML = "Segmentations Loaded"
		clearDivsIn(parent.frames[6].document);
		return(true);
	} else document.getElementById("evaloutput").innerHTML = "Segmentation not found"
	return(false)
}

function included(obj,arr) {
	for (var i=0;i<arr.length;i++) {
		if (arr[i]==obj) {
			return(true);
		}
	}
	return(false);
}

function startEvaluation(tr,tt,algo1,algo2,browser1,browser2,collection_id) {
	
	e.evaluate(tr,tt);
	
	clearDivsIn(parent.frames[6].document);
	
	var ss="";
	var tc;
	var gnode,snode,gnodeins,gn,gs;
	
	//auxiliar metrics
	var sigedgesG = 0;
	var sigedgesS = 0;
	var incidentG = 0;
	var incidentS = 0;
	
	//metrics
	var tc = 0;
	var to = 0;
	var tu = 0;
	var co = 0;
	var cu = 0;
	var cm = 0;
	var cf = 0;
	
	var ss="";
	var zz="";
	var status="";
	ss+="<table border=1 width='100%'>"
	ss+="<tr><td>"+algo1+" Nodes</td><td>"+algo2+" Nodes</td></tr>"
	ss+="<tr valign='top'><td>"
	ss+="<table border=1>"
	for (var k=0;k<e.gt.blocks.length;k++) {
		gnode = e.gt.blocks[k];
		glist = e.graphG[gnode.id] || undefined;
		if (glist) {
			gn=glist.nodes.length;
			sigedgesG+=gn;
			incidentG++;
			status="";
			if (gn>1) {co++;status="is oversegmented by";}
			if (gn==0) {cm++;status="is missed";}
			var aa=""
			for (var n=0;n<glist.nodes.length;n++) {
				snode = glist.nodes[n] ;
				slist = e.graphS[snode.id] || undefined;
				if (slist) {
					sn = slist.nodes.length;
					gnodeins = included(gnode,slist.nodes);
					aa+="<tr><td>" +snode.id+" ("+sn+","+e.proportion(gnode,snode,tt)+")</td></tr>";
					//~ ss+="<td>" +snode.id+" ("+sn+"),("+gnodeins+")</td>";
					if ((gn == sn) && (gn == 1) && gnodeins) {tc++;status="is correct";}
					if ((sn>1) && (gn == 1) && gnodeins) {co+=1;status="is oversegmented by";}
					
				}
			}
			ss+="<tr><td>"+gnode.id+" ("+gn+") is "+status+"</td><td><table border=0>";
			ss+=aa;
			ss+="</table></td></tr>";
		} else {
			cm++;
			ss+="<tr><td>"+gnode.id+" (0) (missed)</td><td></td></tr>";
		}
	}
	ss+="</table></td><td><table border=1>"
	for (var k=0;k<e.seg.blocks.length;k++) {
		snode = e.seg.blocks[k];
		slist = e.graphS[snode.id] || undefined;
		if (slist) {
			sn=slist.nodes.length;
			incidentS++;
			sigedgesS+=sn;
			//~ if (sn>1) cu++;
			//~ if (sn==0) cf++;
			status="";
			if (sn>1) {cu++;status="undersegmenting";}
			if (sn==0) {cf++;status="is missed";}
			//~ ss+=snode.id+" ("+sn+")<br>";
			
			var aa="";
			
			for (var n=0;n<slist.nodes.length;n++) {
				gnode = slist.nodes[n] ;
				glist = e.graphG[gnode.id] || undefined;
				if (glist) {
					gn = glist.nodes.length;
					snodeins = included(snode,glist.nodes);
					//~ ss+="---" +gnode.id+" ("+gn+"),("+snodeins+")<br>";
					aa+="<tr><td>" +gnode.id+" ("+gn+","+e.proportion(snode,gnode,tt)+")</td></tr>";
					if ((sn == gn) && (sn == 1) && gnodeins) {status="is correct";}
					if ((gn>1) && (sn == 1) && snodeins) {cu+=1;status="undersegmenting";}
				}
			}
			ss+="<tr><td>"+snode.id+" ("+sn+")  ("+status+")</td><td><table border=0>";
			ss+=aa;
			ss+="</table></td></tr>";
		} else {
			cf++;
			ss+="<tr><td>"+snode.id+" (0) is a false alarm</td><td></td></tr>";
		}
	}
	
	ss+="</td></tr></table></td></tr></table>"
	
	to = sigedgesG-incidentG;
	tu = sigedgesS-incidentS; 

	gtb = e.gt.blocks.length;
	stb = e.seg.blocks.length;
	
	var score;

	score = tc -  0.01*cu - 0.5*cm 
	
zz+='<table border="1" width="100%">';
zz+='	<tr align="center"><td><b>Collection</b></td><td>'+collection_id+'</td></tr>';
zz+='	<tr align="center"><td><b>Page</b></td><td>'+e.page+'</td></tr>';

zz+='	<tr align="center"><td><b>TR</b></td><td>'+tr+'</td></tr>';
zz+='	<tr align="center"><td><b>TT</b></td><td>'+tt+'px</td></tr>';

zz+='	<tr align="center"><td><b>Algorithm1</b></td><td>'+algo1+'@'+browser1+'</td></tr>';
zz+='	<tr align="center"><td><b>TB1</b></td><td>'+gtb+'</td></tr>';

zz+='	<tr align="center"><td><b>Tc</b></td><td>'+tc+'</td></tr>';
zz+='	<tr align="center"><td><b>Co</b></td><td>'+co+'</td></tr>';
zz+='	<tr align="center"><td><b>Cm</b></td><td>'+cm+'</td></tr>';
zz+='	<tr align="center"><td><b>Check1</b></td><td>'+(tc+co+cm)+'</td></tr>';

zz+='	<tr align="center"><td><b>Algorithm2</b></td><td>'+algo2+'@'+browser2+'</td></tr>';
zz+='	<tr align="center"><td><b>TB2</b></td><td>'+stb+'</td></tr>';
zz+='	<tr align="center"><td><b>Tc</b></td><td>'+tc+'</td></tr>';
zz+='	<tr align="center"><td><b>Cu</b></td><td>'+cu+'</td></tr>';
zz+='	<tr align="center"><td><b>Cf</b></td><td>'+cf+'</td></tr>';
zz+='	<tr align="center"><td><b>Check2</b></td><td>'+(tc+cu+cf)+'</td></tr>';

zz+='	<tr align="center"><td><b>Prec</b></td><td>'+(tc/gtb)+'</td></tr>';
zz+='	<tr align="center"><td><b>Score</b></td><td>'+score+'</td></tr>';
zz+='</table>';

	
	
	//~ graph = generateGraphOutput();
	var rnn = Math.floor(Math.random()*10000)
	var getref = "http://www-poleia.lip6.fr/~sanojaa/BOM/results.php?score="+score+"&collection_id="+collection_id+"&url="+escape(e.page)+"&tc="+tc+"&to="+to+"&tu="+tu+"&co="+co+"&cu="+cu+"&cm="+cm+"&cf="+cf+"&tt="+tt+"&algorithm1="+algo1+"&algorithm2="+algo2+"&gtb="+gtb+"&stb="+stb+"&browser1="+browser1+"&browser2="+browser2+"&tr="+tr+"&rnd="+rnn;
	//~ var getref = "http://localhost/BOM/results.php?category="+e.gt.category+"&url="+escape(e.page)+"&tc="+tc+"&to="+to+"&tu="+tu+"&co="+co+"&cu="+cu+"&cm="+cm+"&cf="+cf+"&tt="+tt+"&algorithm1="+algo1+"&algorithm2="+algo2+"&gtb="+gtb+"&stb="+stb+"&browser1="+browser1+"&browser2="+browser2+"&rnd="+rnn;
	
	if (parent.batchmode) {
		var request = new XMLHttpRequest();
		request.open('GET',getref,false);
		request.send(null);
		
		if (request.status == 200) {
			document.getElementById("evaloutput").innerHTML = request.responseText;
			
		} else {
			console.log("Data not saved. Status="+request.status);
		}
	} else {
		var ff="<input type='button' onclick=\"location.href='"+getref+"'\" value='Send Results'/><br>";
		document.getElementById("evaloutput").innerHTML = ff+zz+ss;
		
	}
	//~ var matrix = e.generateMatrix();
	//generateGraphOutput();
}

function generateGraphOutput() {
	var gnodes=[],snodes=[],text;
	for (var g=0;g<e.gt.blocks.length;g++) {
		gcir[g] = paper.circle(100,40+desp,20);
		gcir[g].attr('fill','#FFFFFF');
		gcir[g].attr('stroke','black');
		text = paper.text(100,40+desp,e.gt.blocks[g].id);
	}
	desp=0;
	for (var s=0;s<e.seg.blocks.length;s++) {
		desp=desp+60
		scir[s] = paper.circle(600,40+desp,20);
		scir[s].attr('fill','#FFFFFF');
		scir[s].attr('stroke','black');
		text = paper.text(600,40+desp,e.seg.blocks[s].id);
	}
}

function draw(seg,win,border,fill) {
	var canvas = new rectObj();
	canvas.init(win);
	canvas.build(0,0,300,300,"2px dotted red","transparent","");
	var rect;
	for (var i=0;i<seg.blocks.length;i++) {
		var dim = seg.blocks[i].computedRect;
		//cont = dim.x+" "+dim.y+" "+dim.w+" "+dim.h;
		cont=seg.blocks[i].id;
		if (!border) border = "2px solid red";
		if (!fill) fill = "rgba(0,0,255,0.5)";
		rect = canvas.build(dim.x*3,dim.y*3,(dim.w-dim.x)*3,(dim.h-dim.y)*3,border,fill,cont);
		parent.drawings.push(rect);
		//~ console.log(seg.blocks[i])
	}
}


function clearDivsIn(doc) {
	var divs = doc.getElementsByTagName("div");
	for (var k=divs.length-1;k>=0;k--) doc.body.removeChild(divs[k]);
}

function dummy() {
	console.log("I'm waiting...");
}

function drawCurrentRects(r1,r2,tt) {
	clearDivsIn(parent.frames[6].document);
	var canvas = new rectObj();
	var rect1,rect2;
	canvas.init(parent.frames[6]);
	border = "2px solid red";
	var dim1 = r1.computedRect;
	var dim2 = r2.computedRect;
	
	fill = "blue";
	rect1 = canvas.build((dim1.x-tt)*2,(dim1.y-tt)*2,(dim1.w-dim1.x+tt)*2,(dim1.h-dim1.y+tt)*2,border,fill,r1.id,r1.id);
	fill = "green";
	rect2 = canvas.build(dim2.x*2,dim2.y*2,(dim2.w-dim2.x)*2,(dim2.h-dim2.y)*2,border,fill,r2.id,r2.id);
}

</script>
<script type="text/javascript">
        
            var selectors, lastTarget;
            
            selectors = {
                crops : 'input[name=crop]',
                crop  : 'input[name=crop]:checked'
            };
            
            function round() {
                return false; //$('input[name=round]:checked').length === 1;
            }
            
            function reset() {
                lastTarget = undefined;
                $('#arc input[name=x1]').val(1024);
                $('#arc input[name=y1]').val(768);
                $('#arc input[name=x2]').val('');
                $('#arc input[name=y2]').val('');
                onKeyup({});
            }
            
            /**
             * Reduce a numerator and denominator to it's smallest, integer ratio using Euclid's Algorithm
             */
            function reduceRatio(numerator, denominator) {
                var gcd, temp, divisor;
                
                // from: http://pages.pacificcoast.net/~cazelais/euclid.html
                gcd = function (a, b) { 
                    if (b === 0) return a;
                    return gcd(b, a % b);
                }
                
                // take care of some simple cases
                if (!isInteger(numerator) || !isInteger(denominator)) return '? : ?';
                if (numerator === denominator) return '1 : 1';
                
                // make sure numerator is always the larger number
                if (+numerator < +denominator) {
                    temp        = numerator;
                    numerator   = denominator;
                    denominator = temp;
                }
                
                divisor = gcd(+numerator, +denominator);
                
                return 'undefined' === typeof temp ? (numerator / divisor) + ' : ' + (denominator / divisor) : (denominator / divisor) + ' : ' + (numerator / divisor);
            };
            
            function ratio2css(numerator, denominator) {
                var width, height;
                
                if (+numerator > +denominator) {
                    width  = 200;
                    height = solve(width, undefined, numerator, denominator);
                }
                else {
                    height = 200;
                    width  = solve(undefined, height, numerator, denominator);
                }
                
                return {
                    width      : width + 'px',
                    height     : height + 'px',
                    lineHeight : height + 'px'
                };
            }
            
            /**
             * Determine whether a value is an integer (ie. only numbers)
             */
            function isInteger(value) {
                return /^[0-9]+$/.test(value);
            };
            
            /**
             * Solve for the 4th value
             * @param int num2 Numerator from the right side of the equation
             * @param int den2 Denominator from the right side of the equation
             * @param int num1 Numerator from the left side of the equation
             * @param int den1 Denominator from the left side of the equation
             * @return int
             */
            function solve(width, height, numerator, denominator) {
                var value;
                
                // solve for width
                if ('undefined' !== typeof width) {
                    value = round() ? Math.round(width / (numerator / denominator)) : width / (numerator / denominator);
                }
                // solve for height
                else if ('undefined' !== typeof height) {
                    value = round() ? Math.round(height * (numerator / denominator)) : height * (numerator / denominator);
                }
                
                return value;
            }
        </script>

</head>
<body>
<div id="evaloutput"></div>
</body>
</html>
